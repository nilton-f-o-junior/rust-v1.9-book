<!DOCTYPE HTML>
<html lang="pt-br" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust v1.9 - Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust v1.9 - Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/nilton-f-o-junior/rust-developer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="menos-teoria-mais-rust"><a class="header" href="#menos-teoria-mais-rust">Menos Teoria, Mais Rust</a></h1>
<p>Rust é famosa por sua velocidade, segurança e prevenção de bugs. Mas por onde começar? O livro oficial é ótimo, mas às vezes queremos apenas ir direto ao ponto.</p>
<p>É por isso que este livro existe.</p>
<p>Ele foi criado para ser sua ponte entre a teoria complexa e o código funcional, facilitando sua introdução à linguagem qualquer que seja seu nível. A abordagem é direta: menos teoria, mais prática.</p>
<p>O que você encontrará aqui:</p>
<ul>
<li>Inúmeros exemplos;</li>
<li>Perguntas rápidas de fixação (3 a 5 minutos);</li>
<li>Projetos para por a mão na massa;</li>
<li>Links com material complementar.</li>
</ul>
<p>Vamos começar a programar?</p>
<div style="break-before: page; page-break-before: always;"></div><p>"A beleza que vive no ato de compartilhar algo com os outros." Monja Coen</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introdução-ao-rust"><a class="header" href="#introdução-ao-rust">Introdução ao Rust</a></h1>
<p>Rust foi criado por <strong>Graydon Hoare</strong> na Mozilla Research em <strong>2010</strong>. A primeira versão estável, 1.0, foi lançada em 2015, marcando o início de sua popularidade e adoção mais ampla na indústria.</p>
<p>Rust é uma linguagem de código aberto (<em>open-source</em>) e compilada, o que significa que é traduzida diretamente para código de máquina. Isso a torna extremamente rápida, sem a necessidade de um interpretador como Python ou JavaScript. Ela se posiciona como uma alternativa a linguagens como C e C++, que são conhecidas por sua performance, mas também são mais suscetíveis a erros de memória, como <em>null pointers</em> (ponteiros nulos) ou <em>data races</em> (condições de corrida de dados).</p>
<p>A grande inovação do Rust é o <em>Ownership Model</em> (Modelo de Posse), um sistema que garante a segurança de memória em tempo de compilação. Isso significa que o compilador do Rust verifica se o seu código está livre de erros de memória antes mesmo de ser executado. O compilador se torna um "guardião" da memória, e se ele não aprovar o seu código, ele simplesmente não compila. Essa abordagem elimina toda uma classe de bugs que são comuns em outras linguagens.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="começando"><a class="header" href="#começando">Começando</a></h1>
<p>Olá, seja bem-vindo!</p>
<p>Este projeto foi criado não apenas para ajudá-lo a aprender a linguagem, mas também como um material de consulta. A longo prazo, este conteúdo será expandido continuamente, até se tornar algo mais completo e abordar de forma simples diversos tópicos complexos que ainda carecem de documentação, principalmente em português.</p>
<p>Espero de coração que você consiga aprender junto comigo e que este material lhe seja tão útil quanto tem sido para mim. Aproveite bem o que foi construído até aqui e continue acompanhando, pois novos conteúdos serão adicionados regularmente.</p>
<p>Bons estudos!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-playground"><a class="header" href="#rust-playground">Rust Playground</a></h1>
<p>O Rust Playground é a maneira mais rápida de começar a experimentar com Rust. É um ambiente online onde você pode:</p>
<ul>
<li>Escrever e rodar código Rust diretamente no seu navegador;</li>
<li>Testar pequenos exemplos e conceitos;</li>
<li>Compartilhar código com outros desenvolvedores;</li>
<li>Experimentar sem a necessidade de instalar nada.</li>
</ul>
<blockquote>
<p>Acesse: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=af33bc1a9e97e7e4360131b09fa5d1e3">https://play.rust-lang.org</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instalando"><a class="header" href="#instalando">Instalando</a></h1>
<p>Para instalar no macOS, Linux ou em outros sistemas operacionais tipo Unix, execute o seguinte em seu terminal e siga as instruções na tela:</p>
<pre><code class="language-md">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>Certifique-se de visitar o site oficial do Rust para melhor entender o processo de instalação e outras ferramentas:</p>
<pre><code class="language-md">https://www.rust-lang.org/tools/install
</code></pre>
<p>Se você estiver no Windows, procure por "Outros Métodos de Instalação":</p>
<pre><code class="language-md">https://forge.rust-lang.org/infra/other-installation-methods.html
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versão"><a class="header" href="#versão">Versão</a></h1>
<p>Se você deseja ver a versão do Rust:</p>
<pre><code class="language-md">rustc --version
</code></pre>
<p>Se você deseja ver a versão do Cargo:</p>
<pre><code class="language-md">cargo --version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="desinstalando"><a class="header" href="#desinstalando">Desinstalando</a></h1>
<p>Se em algum momento você quiser desinstalar o Rust:</p>
<pre><code class="language-md">rustup self uninstall
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editores-e-ides"><a class="header" href="#editores-e-ides">Editores e IDEs</a></h1>
<p><strong>Zed</strong></p>
<p>Um editor de código moderno e extremamente rápido, desenvolvido pelos criadores do Atom, focado em desempenho e colaboração em tempo real.</p>
<pre><code class="language-md">https://zed.dev/
</code></pre>
<p><strong>RustRover: IDE Rust da JetBrains</strong></p>
<p>É a IDE dedicada da JetBrains para Rust, oferecendo recursos avançados de desenvolvimento, como depuração inteligente, <em>refactoring</em> (refatoração) e análise de código.</p>
<pre><code class="language-md">https://www.jetbrains.com/rust/
</code></pre>
<p><strong>VS Code: com a extensão rust-analyzer</strong></p>
<p>É uma combinação popular e leve para o desenvolvimento em Rust, oferecendo <em>autocomplete</em> (autocompletar), verificação de erros em tempo real e integração com as ferramentas do ecossistema Rust.</p>
<pre><code class="language-md">https://code.visualstudio.com/
</code></pre>
<pre><code class="language-md">https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer  
</code></pre>
<p><strong>Helix</strong></p>
<p>Editor de texto modal moderno inspirado em Vim/Kakoune, com suporte nativo a LSP (<em>Language Server Protocol</em>) e destaque de sintaxe, oferecendo uma experiência de edição rápida e eficiente sem a necessidade de configuração inicial.</p>
<pre><code class="language-md">https://helix-editor.com/  
</code></pre>
<details>
  <summary>Config: languages.toml</summary>
<pre><code class="language-md">[[language]]
name = "rust"
auto-format = true

roots = [
  "Cargo.toml",
  "Cargo.lock"
]

[language.auto-pairs]
'(' = ')'
'{' = '}'
'[' = ']'
'"' = '"'
'`' = '`'

[language-server.rust-analyzer]
command = "rust-analyzer"

[language-server.rust-analyzer.config]
inlayHints.bindingModeHints.enable = false
inlayHints.closingBraceHints.minLines = 10
inlayHints.closureReturnTypeHints.enable = "with_block"
inlayHints.discriminantHints.enable = "fieldless"
inlayHints.lifetimeElisionHints.enable = "skip_trivial"
inlayHints.typeHints.hideClosureInitialization = false    
</code></pre>
</details>
<p><strong>Neovim: com plugins específicos para Rust</strong></p>
<p>Evolução moderna do Vim com suporte nativo a LSP, interface assíncrona e extensibilidade via Lua, sendo altamente customizável e ideal para desenvolvedores que buscam um editor modal poderoso e eficiente.</p>
<pre><code class="language-md">https://neovim.io/
</code></pre>
<pre><code class="language-md">https://rsdlt.github.io/posts/rust-nvim-ide-guide-walkthrough-development-debug/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conceitos-comuns-de-programação"><a class="header" href="#conceitos-comuns-de-programação">Conceitos Comuns de Programação</a></h1>
<p>Este capítulo foi desenvolvido para apresentar os conceitos fundamentais da linguagem de programação Rust. No entanto, os tópicos abordados aqui também estão presentes em outras linguagens de programação. Se esta é a primeira vez que você se depara com esses conceitos, espero que você possa entender cada ponto claramente, pois isso forma a base essencial para o que virá nos próximos capítulos.</p>
<p>No final, você encontrará alguns exercícios práticos, permitindo que você verifique se perdeu algum conceito durante seus estudos. Mas não se preocupe, as perguntas são muito simples e incluem as respostas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comentários"><a class="header" href="#comentários">Comentários</a></h1>
<p>Comentários são usados para documentar seu código, tornando-o mais compreensível para você e outros desenvolvedores. Eles são ignorados pelo compilador, o que significa que não afetam como seu programa é executado, apenas a sua legibilidade.</p>
<p><code>//</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Este é um comentário de linha única.
<span class="boring">}</span></code></pre></pre>
<p><code>/* */</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*
  ...
  Este é um comentário de múltiplas linhas.
  ...
*/
<span class="boring">}</span></code></pre></pre>
<p><code>///</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Comentários de documentação (doc comments):
///  - Geram documentação automaticamente: cargo doc;
///  - São compatíveis com markdown;
///  - Documentam o item seguinte: função, módulo, struct, etc.
<span class="boring">}</span></code></pre></pre>
<p><code>//!</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Comentário de documentação interno (inner doc comment):
//!  - Documenta módulos/crates: lib.rs;
//!  - Colocado no início dos arquivos.
<span class="boring">}</span></code></pre></pre>
<p><code>/* // /**/ */</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* Comentários aninhados (nested comments):
    // Rust permite comentários dentro do bloco de comentário.
    /* ... */
*/
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="print"><a class="header" href="#print">Print</a></h1>
<p>A macro <code>print!</code> e suas variações são usadas para depuração, informar o usuário e gerar saída formatada.</p>
<p><code>print!</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// imprime o texto sem quebra de linha
print!("Olá,");
print!("mundo!");
print!("...");
<span class="boring">}</span></code></pre></pre>
<p><code>println!</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// imprime o texto com quebra de linha
println!("Olá,");
println!("mundo!");
println!("...");
<span class="boring">}</span></code></pre></pre>
<p><code>eprint!</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// imprime o texto de erro sem quebra de linha
eprint!("ERRO:");
eprint!("Falha ao carregar arquivo!");
<span class="boring">}</span></code></pre></pre>
<p><code>eprintln!</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// imprime o texto de erro com quebra de linha
eprintln!("ERRO:");
eprintln!("Falha ao carregar arquivo!");
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Nota: Quando estiver desenvolvendo um programa, pode redirecionar a saída normal para um arquivo usando (&gt;) e as mensagens de erro para o terminal usando (eprint).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caracteres-de-escape"><a class="header" href="#caracteres-de-escape">Caracteres de Escape</a></h1>
<p>São aqueles que começam com <code>\</code> e são usados para representar caracteres especiais que não podemos (ou não devemos) digitar literalmente no código, como quebras de linha, tabulações, aspas dentro de strings, etc.</p>
<p><code>\n</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// quebra de linha
println!("Qual é o seu nome?\nMeu nome é Alice!");
<span class="boring">}</span></code></pre></pre>
<p><code>\'</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// aspas simples
println!("Qual é o seu nome?\'Meu nome é Alice!\'");
<span class="boring">}</span></code></pre></pre>
<p><code>\"</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// aspas duplas
println!("Qual é o seu nome?\"Meu nome é Alice!\"");
<span class="boring">}</span></code></pre></pre>
<p><code>\\</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// barra invertida
println!("Qual é o seu nome?\\Meu nome é Alice!\\");
<span class="boring">}</span></code></pre></pre>
<p><code>\t</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tabulação horizontal (tab)
println!("Qual é o seu nome?\tMeu nome é\tAlice!");
<span class="boring">}</span></code></pre></pre>
<p><code>r</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// permite todas as barra invertidas
println!(r"C:\Users\Alice\Documents");
<span class="boring">}</span></code></pre></pre>
<p><code>r#...#</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// raw strings (string literal/sem processamento de escape)
println!(r#"
  Qual é o seu nome?
  Meu nome é "Alice!"
"#);
<span class="boring">}</span></code></pre></pre>
<p><code>\x</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// caractere ASCII de 7 bits - 0x00 e 0x7F
println!("\x53\x6E\x6F\x6F\x70\x79\x21");
<span class="boring">}</span></code></pre></pre>
<p><code>\u{...}</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// unicode (permite usar emojis ou caracteres especiais)
println!("(\u{25D5}\u{2323}\u{25D5})");
<span class="boring">}</span></code></pre></pre>
<p><code>\r</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// move o cursor de volta para o início da linha sem avançar para a próxima
print!("Carregando ...\r");
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Comumente usado para animações de terminal: <strong>\r</strong></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variáveis"><a class="header" href="#variáveis">Variáveis</a></h1>
<p>Variáveis são espaços nomeados na memória que podem armazenar um valor.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nome = "Maria";
println!("Qual é o seu nome: {}", nome);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let idade = 29;
println!("Qual sua idade? {}", idade);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Saiba mais sobre <a href="https://www.foj.dev.br/src/pages/posts-rust/rust-variables.html">variáveis</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutabilidade"><a class="header" href="#mutabilidade">Mutabilidade</a></h1>
<p>Uma vez que o valor de uma variável é definido, você não pode alterá-lo posteriormente. No entanto, usar <code>mut</code> após <code>let</code> torna a variável criada mutável.</p>
<p><code>let mut</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut nome = "Miguel";
println!("Qual é o seu nome: {}", nome);

nome = "Sophia";
println!("Qual é o seu nome: {}", nome);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut idade = 87;
println!("Qual sua idade? {}", idade);

idade = 49;
println!("Qual sua idade? {}", idade);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constante"><a class="header" href="#constante">Constante</a></h1>
<p>A constante é uma identificador com valor fixo e imutável, tipo explícito e pode ser declarada em qualquer escopo.</p>
<pre><pre class="playground"><code class="language-rust">const PI: f32 = 3.14159;

fn main () {
    println!("{:.2}", PI);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">const ERROR_404: &amp;str = "Erro 404";

fn main () {
    println!("{}", ERROR_404);
}</code></pre></pre>
<blockquote>
<p>O tópico de <strong>tipos de dados</strong> será abordado no próximo capítulo.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatação"><a class="header" href="#formatação">Formatação</a></h1>
<p>A macro <code>format!</code> em Rust é usada para melhorar a formatação da saída de dados, utilizando <code>{}</code> como <em>placeholders</em> (espaços reservados) que serão preenchidos com a informação.</p>
<p><code>{}</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nome = "Rafael";
let idade = 12;
println!("Oi, eu sou {}, tenho {} anos", nome, idade);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nome = "Manuela";
let idade = 37;
println!("Oi, eu sou {nome}, tenho {idade} anos");
<span class="boring">}</span></code></pre></pre>
<p><code>format!</code></p>
<p>Sempre retorna uma <code>String</code> com o conteúdo formatado.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nome = "Arthur";
let idade = 69;

let texto = format!("Oi, eu sou {}, tenho {} anos", nome, idade);
println!("{}", texto);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nome = "Charlie Brown";
let idade = 8;

let texto = format!("Eu sou o {nome}, tenho {idade} anos");
println!("{}", texto);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Para mais informações: <a href="https://doc.rust-lang.org/std/fmt/">std::fmt</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatação-para-debugging"><a class="header" href="#formatação-para-debugging">Formatação para Debugging</a></h1>
<p>Em Rust, <code>{:?}</code> e <code>{:#?}</code> são especificadores de formato que utilizam o <em>trait</em> <code>Debug</code> para exibir a representação interna de valores. São especialmente úteis para depuração e inspeção durante o desenvolvimento.</p>
<p><code>{:?}</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// saída compacta
let pessoa: (&amp;str, u8, f32) = ("Laura", 19, 1.77);
println!("{:?}", pessoa);
<span class="boring">}</span></code></pre></pre>
<p><code>{:#?}</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// saída mais legível
let pessoa: (&amp;str, u8, f32) = ("Pedro", 90, 1.90);
println!("{:#?}", pessoa);
<span class="boring">}</span></code></pre></pre>
<p><code>{var:?} ou {var:#?}</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pessoa: (&amp;str, u8, f32) = ("Violet", 28, 1.58);
println!("{pessoa:?}");
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pessoa: (&amp;str, u8, f32) = ("Violet", 28, 1.58);
println!("{pessoa:#?}");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadowing-sombreamento"><a class="header" href="#shadowing-sombreamento">Shadowing (Sombreamento)</a></h1>
<p>Você pode declarar uma nova variável com o mesmo nome de uma variável existente, mas a variável anterior é ocultada (<em>shadowed</em>) pela nova.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let comida = "Pizza";
println!("{}", comida);

let comida = "Biscoitos";
println!("{}", comida);

let comida = "Sorvete";
println!("{}", comida);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let animal = "Cachorro";
println!("{}", animal);

let animal = "Pássaro";
println!("{}", animal);

let animal = "Gato";
println!("{}", animal);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numero: i8 = 80;
println!("{}", numero);

let numero: f32 = 2.;
println!("{}", numero);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escopo"><a class="header" href="#escopo">Escopo</a></h1>
<p>Envolver um código entre chaves <code>{}</code> cria um novo escopo (bloco de código) que limita a visibilidade das variáveis definidas dentro dele, logo não pode ser acessada fora daquele bloco.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let nome = "Aurora";
println!("{}", nome);

{
  let nome = "Ravi";
  println!("{}", nome);
}

println!("{}", nome);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numero = 40;
println!("{}", numero);

{
  let numero = 0;
  println!("{}", numero);
}

println!("{}", numero);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questões---conceitos-comuns-de-programação"><a class="header" href="#questões---conceitos-comuns-de-programação">Questões - Conceitos Comuns de Programação</a></h1>
<hr />
<p>01 - Como você escreveria um comentário de linha única em Rust?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=11d0d9b36b3ec6d7e026556a2df259f3">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Este é um comentário de linha única    
}</code></pre></pre>
</details>
<p>02 - Qual é a sintaxe para comentários de bloco em Rust?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=92ccdce85429042c3c19b90b2739c098">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    /*
      Este é um comentário de
      bloco que abrange várias
      linhas.
    */
}</code></pre></pre>
</details>
<p>03 - Você pode aninhar comentários de bloco em Rust? Dê um exemplo.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=b385f4e4d830c51899b10fd20c3df383">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    /*
       Inicio do comentário externo
       // Este é um comentário aninhado
       Fim do comentário externo
    */    
}</code></pre></pre>
</details>
<p>04 - Qual macro você usaria para imprimir texto na mesma linha, sem adicionar uma quebra de linha no final?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=6f1d77bf1df6b37e13be0394858d6faa">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print!("Imprimir sem adicionar uma nova linha no final!");
}</code></pre></pre>
</details>
<p>05 - Qual macro você usaria para imprimir texto e adicionar automaticamente uma quebra de linha no final?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8e657af8456cd2e45c7071387a6e1f30">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Imprimir e adicionar nova linha no final!");
}</code></pre></pre>
</details>
<p>06 - Escreva um código que imprima "<em>Hello</em>" e "<em>World</em>" na mesma linha usando a macro print!.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=7f19b20530592369971fba8bf265a206">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print!("Hello, ");
    print!("World");
}</code></pre></pre>
</details>
<p>07 - Como você insere uma quebra de linha explícita dentro de uma string que está sendo impressa com println!?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=1473956c103116618b8e9d7b11d738d5">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Primeira linha\nSegunda linha");
}</code></pre></pre>
</details>
<p>08 - Que outras sequências de escape você pode usar em strings Rust? Dê exemplos de pelo menos 3.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=eb0dfd113278e39b07935fe967a36e6f">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Barra invertida: \\");
    println!("Olá \"mundo\"");
    println!(r"C:\Usuários\Snoopy\Documentos\");
}</code></pre></pre>
</details>
<p>09 - Como você declara uma variável chamada score e atribui a ela o valor 100?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=e2483e071f7668c29ab6d4c43e93d5bc">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let score = 100;
    println!("Score: {}", score);
}</code></pre></pre>
</details>
<p>10 - Escreva uma linha de código que declare uma variável cidade com o valor Recife e a imprima na tela.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=534c15c5dd3777cd8b43f590b00e6898">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let cidade = "Recife";
    println!("Cidade: {}", cidade);
}</code></pre></pre>
</details>
<p>11 - O que acontece se você tentar usar uma variável antes de declará-la em Rust?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=516e91b84059737ccbf05e4b66f15c2d">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Isto causaria um erro de tempo de compilação:
    println!("{}", x);
    let x = 5;
} </code></pre></pre>
</details>
<p>12 - Você pode declarar uma variável sem inicializá-la em Rust? Se sim, mostre como usá-la com segurança.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=29057131611a1196cdecaf62afc029c5">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32; 
    x = 42;     
    println!("x = {}", x);
}</code></pre></pre>
</details>
<p>13 - Declare uma variável mutável chamada contador inicializada com 0. Em seguida, escreva o código para alterar o valor para 5 e imprima.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=0470104c01ad820b44ea02bf1f9b0619">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut contador = 0;
    println!("Contador = {}", contador);
    
    contador = 5;
    println!("Contador = {}", contador);
}</code></pre></pre>
</details>
<p>14 - O que acontece se você tentar modificar uma variável imutável em Rust?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=6a85529111197c9537205effe189f958">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 1;    
    x = 2;
    println!("x = {}", x);
}</code></pre></pre>
</details>
<p>15 - Como você declara uma constante chamada <em>MAX_SPEED</em> com o valor "9000" do tipo i32?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=3ca1e4c69ef20b6654436f608fe50592">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">const MAX_SPEED: i32 = 9000;

fn main() {
    println!("Max Speed: {}", MAX_SPEED);
}</code></pre></pre>
</details>
<p>16 - É possível alterar o valor de uma constante após sua declaração?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=db9590e32122bc2e839341fd5f2d6402">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">const MAX_SPEED: i32 = 100;

fn main() {    
    MAX_SPEED = 200;
}</code></pre></pre>
</details>
<p>17 - Quais são as principais diferenças entre constantes e variáveis imutáveis em Rust?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=3d4e03767d7986a810cc961681f3b7eb">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">const CONSTANTE_GLOBAL: i32 = 100;

fn main() {
    let variavel_imutavel = 200;
    println!("Constante: {}, Variável: {}", CONSTANTE_GLOBAL, variavel_imutavel);

    // Constantes:
    // - Sempre imutáveis (a palavra-chave 'mut' não é permitida);
    // - Tipo explícito (ex: : i32);
    // - Podem ser declaradas em escopo global (fora de funções).
    
    // Variáveis Imutáveis (let):
    // - Podem ser tornadas mutáveis com 'mut';
    // - O tipo pode ser inferido;
    // - Locais ao seu escopo;
    // - Podem ser definidas como o resultado de qualquer expressão.
}</code></pre></pre>
</details>
<p>18 - Como você usaria a macro format! para criar a string "O valor é: 42" a partir do número 42?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8369e2438b56bc2abda06aff8bc3c285">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero = 42;
    let numero_formatado = format!("O valor é: {}", numero);
    println!("{}", numero_formatado);
}</code></pre></pre>
</details>
<p>19 - Como você pode formatar o número "7" para que ele seja exibido como "0007" usando format!?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=b9fb3b5c41ed8919cabd2aecd712f4e3">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero = 7;
    let numero_formatado = format!("{:04}", numero);
    println!("{}", numero_formatado);
}</code></pre></pre>
</details>
<p>20 - Como você formataria um número de ponto flutuante para mostrar exatamente 2 casas decimais?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=f7731cabfc66bf0003f674f81c79d382">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pi = 3.14159265359;
    println!("Pi: {:.2}", pi);

    let pi_formatado = format!("{:.2}", pi);
    println!("Pi: {}", pi_formatado);    
}</code></pre></pre>
</details>
<p>21 - Demonstre como usar argumentos posicionais em format strings.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=cd343f4c9020844b7b181f431570417f">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nome = "Snoopy";
    let idade = 8;
    let cidade = "Califórnia";
    
    // Argumentos posicionais
    println!("{0} tem {1} anos e mora na {2}", nome, idade, cidade);
    
    // Argumentos nomeados
    println!("{nome} tem {idade} anos e mora na {cidade}");
             
    // Misturado
    println!("{} tem {idade} anos e mora na {cidade}", nome);
}</code></pre></pre>
</details>
<p>22 - O que é <em>shadowing</em> em Rust? Explique com um exemplo de código e qual seria a saída.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=f482540cb33e01d48f2a776d37773d87">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    println!("Primeiro x: {}", x);

    let x = x + 1;
    println!("Segundo x: {}", x);

    let x = x * 2;
    println!("Terceiro x: {}", x);

    let x = "Olá";
    println!("Quarto x: {}", x);
}</code></pre></pre>
</details>
<p>23 - Qual será a saída do seguinte código?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=7e38fa1f3187c185c9c24902bb40bb9d">Playground!</a></p>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let x = 5;
    let x = x + 1;
    {
        let x = x * 2;
        println!("O valor interno de x é: {}", x);
    }
    println!("O valor externo de x é: {}", x);
}</code></pre></pre>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let x = x + 1; // x = 6
    {
        let x = x * 2; // x = 12 
        println!("O valor interno de x é: {}", x); // Saida: 12
    }
    println!("O valor externo de x é: {}", x); // Saida: 6
}</code></pre></pre>
</details>
<p>24 - Qual será a saída do seguinte código? Explique por quê.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=59ac6475810ab64b4bf02825573cff00">Playground!</a></p>
<pre><pre class="playground"><code class="language-rust">fn main () {    
    let a = 10;
    {
        let b = 20;
        println!("Dentro do bloco: a = {}, b = {}", a, b);
    }
    println!("Fora do bloco: b = {}", b);
}</code></pre></pre>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 10;
    {
        let b = 20;
        println!("Dentro do bloco: a = {}, b = {}", a, b);
        // Saida: Dentro do bloco: a = 10, b = 20
    }
    // println!("Fora do bloco: b = {}", b);
    // Erro: b não está no escopo
}</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-de-dados"><a class="header" href="#tipos-de-dados">Tipos de Dados</a></h1>
<p>Este capítulo explora os tipos de dados fundamentais disponíveis no Rust, cobrindo os blocos de construção essenciais que você usará para armazenar e manipular informações em seus programas. Compreender esses tipos de dados é crucial para escrever código Rust eficiente, pois cada tipo possui características específicas, requisitos de memória e casos de uso.</p>
<p>Uma das principais forças do Rust é o seu sistema de tipagem estática, o que significa que o compilador sabe o tipo exato de cada variável em tempo de compilação, proporcionando benefícios tanto em segurança quanto em desempenho. Assim como nos capítulos anteriores, exercícios práticos são fornecidos no final para reforçar sua compreensão e garantir que você esteja pronto para prosseguir com confiança.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u-inteiros-não-assinados"><a class="header" href="#u-inteiros-não-assinados">u: inteiros não-assinados</a></h1>
<p>São tipos de dados que só podem armazenar números inteiros positivos ou zero.</p>
<p><code>u8</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// u8 = 0 a 255
let inteiro: u8 = 16;
println!("{}", inteiro);
<span class="boring">}</span></code></pre></pre>
<p><code>u16</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// u16 = 0 a 65_535
let inteiro: u16 = 32;
println!("{}", inteiro);
<span class="boring">}</span></code></pre></pre>
<p><code>u32</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// u32 = 0 a 4_294_967_295
let inteiro: u32 = 64;
println!("{}", inteiro);
<span class="boring">}</span></code></pre></pre>
<p><code>u64</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// u64 = 0 a 18_446_744_073_709_551_615
let inteiro: u64 = 128;
println!("{}", inteiro);
<span class="boring">}</span></code></pre></pre>
<p><code>u128</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// u128 = 0 a ...
let inteiro: u128 = 256;
println!("{}", inteiro);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i-inteiros-assinados"><a class="header" href="#i-inteiros-assinados">i: inteiros assinados</a></h1>
<p>São tipos de dados que só podem armazenar números inteiros positivos, negativos ou zero.</p>
<p><code>i8</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// i8 = -128 a 127
let inteiro: i8 = 16;
println!("{}", inteiro);
<span class="boring">}</span></code></pre></pre>
<p><code>i16</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// i16 = -32_768 a 32_767
let inteiro: i16 = 32;
println!("{}", inteiro);
<span class="boring">}</span></code></pre></pre>
<p><code>i32</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// i32 = -2_147_483_648 a 2_147_483_647
let inteiro: i32 = 64;
println!("{}", inteiro);
<span class="boring">}</span></code></pre></pre>
<p><code>i64</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// i64 = -9_223_372_036_854_775_808 a 9_223_372_036_854_775_807
let inteiro: i64 = 128;
let inteiro: i64 = 9_223_372_036_854_775_807;
println!("{}", inteiro);
<span class="boring">}</span></code></pre></pre>
<p><code>i128</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// i128 =  ... a ...
let inteiro: i128 = 256;
println!("{}", inteiro);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="f32-e-f64-ponto-flutuante"><a class="header" href="#f32-e-f64-ponto-flutuante">f32 e f64: ponto flutuante</a></h1>
<p>São tipos de dados que só podem armazenar números que possuem uma parte fracionária ou números reais, positivos, negativos ou zero.</p>
<p><code>f32</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// f32 = -3.4e+38 a +3.4e+38
let flutuante: f32 =  64.;
println!("{}", flutuante);
<span class="boring">}</span></code></pre></pre>
<p><code>f64</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// f64 = -1.8e+308 to +1.8e+308
let flutuante: f64 =  128.;
println!("{}", flutuante);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool-booleano"><a class="header" href="#bool-booleano">bool: booleano</a></h1>
<p>Representa apenas dois tipos de valores: <em>true</em> (verdadeiro) ou <em>false</em> (falso).</p>
<p><code>true</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let booleano: bool = true;
println!("1 + 1 = 2? {}", booleano);
<span class="boring">}</span></code></pre></pre>
<p><code>false</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let booleano: bool = false;
println!("1 + 1 = 2? {}", booleano);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="char-caractere"><a class="header" href="#char-caractere">char: caractere</a></h1>
<p>Usado para representar um único caractere e requer o uso de aspas simples (por exemplo, 'a').</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let caractere: char = 'a';
println!("{}", caractere);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let simbolo: char = '⭐';
println!("{}", simbolo);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-e-str"><a class="header" href="#string-e-str">String e &amp;str</a></h1>
<p>Sequência de caracteres UTF-8 que pode formar uma palavra ou frase, incluindo letras, números, símbolos ou qualquer outro tipo de caractere especial.</p>
<p><code>String</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frase: String = String::from("Um pouco de Rust para hoje!");
println!("{}", frase);
<span class="boring">}</span></code></pre></pre>
<p><code>&amp;str</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frase: &amp;str = "Chega de Rust por hoje!";
println!("{}", frase);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>O tópico <strong>String e &amp;str</strong> será abordado melhor em um capítulo posterior.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuplas"><a class="header" href="#tuplas">Tuplas</a></h1>
<p>Combinam múltiplos valores de tipos diferentes em uma única estrutura de dados composta com um tamanho fixo.</p>
<p><code>inferência de tipos</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tipos_dados = ("a", 1);
println!("{:?}", tipos_dados);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tipos_dados = ('b', 2.);
println!("{:?}", tipos_dados);
<span class="boring">}</span></code></pre></pre>
<p><code>inferência com atribuição explícita</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tipos_dados: (&amp;str, u8) = ("c", 3);
println!("{:?}", tipos_dados);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tipos_dados: (String, bool) = (String::from("d"), true);
println!("{:?}", tipos_dados);
<span class="boring">}</span></code></pre></pre>
<p><code>Desestruturação com tipos explícitos</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (texto, numero): (&amp;str, i8);
(texto, numero) = ("e", 44);
println!("{}, {}", texto, numero);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (texto, numero): (String, f64);
(texto, numero) = (String::from("f"), 128.5);
println!("{}, {}", texto, numero);
<span class="boring">}</span></code></pre></pre>
<p><code>Desestruturação simples</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (letra, falso): (char, bool) = ('e', false);
let saida =  (letra, falso);
println!("{:?}", saida);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pessoa = ("Gregorio", 64, 1.82);
let (nome, idade, altura) = pessoa;
println!("{}, {}, {}", nome, idade, altura);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modificando-tuplas"><a class="header" href="#modificando-tuplas">Modificando Tuplas</a></h1>
<p>Ao alterar valores de tupla, você precisa especificar o índice do elemento que deseja modificar. Os índices da tupla começam em 0 e correspondem à posição de cada elemento.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//                   0      1    2
let mut perfil = ("Alice", 25, 1.70);

println!("Nome: {:?}", perfil.0);
println!("Idade: {:?}", perfil.1);
println!("Altura: {:?}\n", perfil.2);

perfil.1 = 40;
perfil.2 = 1.55;

println!("Nome: {:?}", perfil.0);
println!("Idade: {:?}", perfil.1);
println!("Altura: {:?}", perfil.2);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut perfil = ("Julio", 90, 1.98);
println!("{:#?}", perfil);

perfil.0 = "Moana";
perfil.1 = 58;
perfil.2 = 1.62;

println!("{:#?}", perfil);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>Uma sequência de elementos de tamanho fixo onde todos os itens devem ser do mesmo tipo de dado.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lista = ["Batata", "Cebola", "Alho", "Cenoura"];
println!("{:?}", lista);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lista: [f32; 4] = [0.2, 0.4, 0.6, 0.8];
println!("{:?}", lista);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lista: [&amp;str; 4];
lista = ["Canadá", "Japão", "Brasil", "Egito"];
println!("{:?}", lista);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [a, b, c]: [char; 3] = ['1', '2', '3'];
let lista = [a, b, c];
println!("{:?}", lista);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lista: [String; 3] = [String::from("A1"), String::from("B2"), String::from("C3")];
let [a, b, c] = lista;
println!("{:?}, {:?}, {:?}", a, b, c);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modificando-arrays"><a class="header" href="#modificando-arrays">Modificando Arrays</a></h1>
<p>Ao alterar valores de array, você precisa especificar o índice do elemento que deseja modificar. Os índices do array começam em 0 e correspondem à posição de cada elemento:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//                0   1   2   3   4
let mut scores = [40, 50, 60, 70, 80];

println!("Score [0]: {}", scores[0]);
println!("Score [1]: {}", scores[1]);
println!("Score [2]: {}\n", scores[2]);

scores[0] = 10;
scores[1] = 20;
scores[2] = 30;

println!("Score [0]: {}", scores[0]);
println!("Score [1]: {}", scores[1]);
println!("Score [2]: {}", scores[2]);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numero: [i32; 5] = [1, 2, 3, 4, 5];
println!("{:#?}", numero);

numero[0] = 10;
numero[2] = 30;
numero[4] = 50;

println!("{:#?}", numero);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut nomes: [&amp;str; 3] = ["Cecília", "Maite", "Helena"];
println!("{:#?}", nomes);

nomes[0] = "Gael";
nomes[1] = "Theo";
nomes[2] = "Rafael";

println!("{:#?}", nomes);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questões---estruturas-de-dados"><a class="header" href="#questões---estruturas-de-dados">Questões - Estruturas de Dados</a></h1>
<hr />
<p>01 - Declare uma variável com nome positivo do tipo u32 com o valor 100. Declare outra variável com nome negativo do tipo i32 com o valor -100. Imprima ambas. Agora, tente atribuir -5 à variável positivo. O que acontece ao tentar compilar e por quê?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=762fa5a6ee5fbd6a01e4f6a2e2352c32">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let positivo: u32 = 100;
    println!("{:?}", positivo);
   
    let negativo: i32 = -100;
    println!("{:?}", negativo);

    // Erro:
    // let positivo: u32 = -5;
}</code></pre></pre>
</details>
<p>02 - Escreva código Rust para declarar uma variável max_u8 do tipo u8 e atribua a ela o maior valor possível para esse tipo. Imprima esse valor e em seguida, no seu código, tente atribuir max_u8 + 1 a uma nova variável u8. O que acontece durante a execução?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=9c7ceb057a84ff7406593de10f9f7510">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let max_u8: u8 = u8::MAX;
    println!("{:?}", max_u8);

    // erro: causaria um overflow (estouro)
    // let max_u8: u8 = u8::MAX + 1;
    // println!("{:?}");
}</code></pre></pre>
</details>
<p>03 - Declare uma variável chamada populacao do tipo u64 e atribua a ela o valor "7_800_000_000". Em seguida, imprima o valor da variável formatada.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=7b2dd4c30f41e8af103bc111ce4435e2">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let populacao: u64 = 7_800_000_000;
    println!("População: {populacao:?}");
}</code></pre></pre>
</details>
<p>04 - Você precisa armazenar a contagem de visualizações de vídeos, que pode chegar a bilhões, mas nunca será negativo. Escolha o tipo não assinado mais apropriado (u32 ou u64). Declare uma variável <em>video_views</em> com este tipo, atribua "2500000000" a ela e imprima.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=792bc57f2e1170e4f56d620ef8a50e03">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let video_views: u64 = 2_500_000_000;
    println!("{:?}", video_views);
}</code></pre></pre>
</details>
<p>05 - Declare duas variáveis, min_val_i8 e max_val_i8, ambas do tipo i8. Atribua a elas, respectivamente, o menor e o maior valor possível para o tipo i8. Imprima ambos os valores.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=2b058d76b81eb1c618eced7c71c8a57a">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let min_val_i8: i8 = i8::MIN;
    println!("{:?}", min_val_i8);
   
    let max_val_i8: i8 = i8::MAX;
    println!("{:?}", max_val_i8);
}</code></pre></pre>
</details>
<p>06 - Tente declarar uma variável valor_a do tipo u8 com 10 e valor_b do tipo u8 com -10. O que acontece com valor_b durante a compilação?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=907d8d41de48f2274b8870609cfba41d">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let valor_a: u8 = 10;
    println!("{:?}", valor_a);

    let valor_b: u8 = -10;
    println!("{:?}", valor_b);
}</code></pre></pre>
</details>
<p>07 - Em um sistema embarcado com memória limitada, você precisa armazenar uma leitura de sensor que varia de -10.0 a +10.0 com duas casas decimais de precisão. Declare uma variável leitura_do_sensor usando f32 e atribua 7.89.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=467533d3ecf12c2ae3e70b631e1a3eae">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let leitura_do_sensor: f32 = 7.89;
    println!("{:?}", leitura_do_sensor);
}</code></pre></pre>
</details>
<p>08 - Declare um caractere ASCII char_ascii = 'Z'; e um caractere unicode char_unicode = 'Ω';. Use std::mem::size_of_val(&amp;char_ascii) e std::mem::size_of_val(&amp;char_unicode) para imprimir o tamanho em bytes de cada um. O que você observa?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=acd43048cb353bfa61f91d7365acc8e1">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let char_ascii: char = 'Z';
    println!("{:?}", char_ascii);

    let char_unicode: char = 'Ω';
    println!("{:?}", char_unicode);

    println!("{:?}", std::mem::size_of_val(&amp;char_ascii));
    println!("{:?}", std::mem::size_of_val(&amp;char_unicode));
}</code></pre></pre>
</details>
<p>09 - Tente declarar uma variável char com mais de um caractere, por exemplo: let letra: char = 'ab';. O que acontece ao tentar compilar?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=f9c9a395b3121b389790b424ce9408db">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // erro: deve ter apenas um caractere
    let letra: char = 'ab';
    println!("{:?}", letra);
}</code></pre></pre>
</details>
<p>10 - Declare uma variável arquivo_carregado e atribua <em>true</em>. Declare apresenta_erro e atribua <em>false</em>. Imprima ambas e em seguida, tente atribuir o inteiro 1 a uma variável booleana. O que o compilador Rust diz?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=161a6b2bace3e1c68a191753f6d36ed8">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arquivo_carregado: bool = true;
    println!("{:?}", arquivo_carregado);

    let apresenta_erro: bool = false;
    println!("{:?}", apresenta_erro);

    // Tipos incompatíveis, esperava-se `bool`, encontrado inteiro
    // let valor: bool = 1;
    // println!("{:?}", valor);
}</code></pre></pre>
</details>
<p>11 - Crie uma tupla registro que contenha um nome (&amp;str), uma idade (u8), e uma nota de aprovação (f32). Exemplo: ("Maria", 22, 7.5). Imprima a tupla inteira.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a27d1e2e86a5c02a258dfc2720bb45ac">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let registro: (&amp;str, u8, f32) = ("Maria", 22, 7.5);
    println!("{:#?}", registro);
}</code></pre></pre>
</details>
<p>12 - Crie uma tupla chamada <em>server_response</em> que contenha um código de <em>status</em> HTTP (u16) e uma mensagem de resposta (&amp;str), como (404, <em>"Not Found"</em>). Imprima a tupla.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=90d02b310161c18de79d363f2a22cb7e">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let server_response: (u16, &amp;str) = (404, "Not Found");
    println!("{:?}", server_response);
}</code></pre></pre>
</details>
<p>13 - Dada a tupla let produto_info = ("Laptop XPTO", 1250.99, 15); (nome, preço, quantidade em estoque), acesse e imprima o preço e a quantidade usando a indexação de tupla (ex: product_info.1).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=01fa6de60ad2dbc546bbd6b56515aff0">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {    
    let produto_info: (&amp;str, f32, u16) = ("Laptop XPTO", 1.250_000, 15);
    let (nome, preco, quantidade_estoque) = produto_info;

    println!(
        "Produto: {} \nQuantidade em Estoque: {}",
        produto_info.0, produto_info.2
    );    
}</code></pre></pre>
</details>
<p>14 - Dada a tupla let color_rgb = (255, 128, 0);, desestruture-a nas variáveis <em>red</em>, <em>green</em> e <em>blue</em>. Imprima cada variável separadamente.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=1d5e4e4f745e9761ae5f508f8623fc1b">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let color_rgb: (u8, u8, u8) = (255, 128, 0);
    let (red, green, blue) = color_rgb;

    println!("Red: {} \nGreen: {} \nBlue: {}", red, green, blue);
}</code></pre></pre>
</details>
<p>15 - Declare uma tupla <em>api_result</em> com um booleano indicando sucesso, um u64 para um ID e uma string para uma mensagem. Ex: (true, 1234567890, String::from(<em>"Successful operation"</em>)). Imprima usando {:#?}.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=d0e73bd37751172ffc26a518f8ce02a0">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let api_result: (bool, u64, String) = (true, 1234567890, String::from("Successful operation"));
    println!("{:#?}", api_result);
}</code></pre></pre>
</details>
<p>16 - Declare uma tupla let config = ("localhost", 8080);. Tente modificar o segundo elemento para 8081 (ex: config.1 = 8081;). O que acontece ao compilar? Agora, redeclare-a como let mut config = ("localhost", 8080); e tente a mesma modificação.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=d9e75d648eceacf486e6ec446ac74680">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // erro: 
    // let config: (&amp;str, u16) = ("localhost", 8080);
    // config.1 = 8180;
    
    let mut config: (&amp;str, u16) = ("localhost", 8080);
    println!("{:?}", config);

    config.1 = 8180;
    println!("{:?}", config);
}</code></pre></pre>
</details>
<p>17 - Declare uma tupla mutável <em>player_status</em> para armazenar nome (&amp;str), <em>score</em> (i32) e vidas (u8). Inicialize com (<em>"Hero"</em>, 0, 3). Em seguida, modifique a pontuação para 1500 e as vidas para 2. Imprima a tupla atualizada.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=1055b59be9f51a685510763916bd06c5">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let player_status: (&amp;str, i32, u8) = ("Hero", 0, 3);
    let (nome, mut score, vidas) = player_status;
    println!("Name: {nome}\nScore: {score}\nVidas: {vidas}\n");
    
    score = 1500;
    println!("Name: {nome}\nScore: {score}\nVidas: {vidas}");
}</code></pre></pre>
</details>
<p>18 - Crie uma tupla mutável let mut point = (10.0, 20.0);. Modifique o primeiro elemento para 15.5 e o segundo para 25.0 usando a sintaxe de acesso por índice. Imprima a tupla.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=c6a2ff5f58b690c5a472c583ef40f49d">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut point: (f32, f32) = (10., 20.);
    println!("{:#?}", point);

    point.0 = 15.5;
    point.1 = 25.;
    println!("{:#?}", point);
}</code></pre></pre>
</details>
<p>19 - Crie uma tupla mutável <em>file_details</em> contendo nome do arquivo (String), tamanho (u64) e se é editável (bool). Inicialize-a. Em seguida, modifique o nome do arquivo (anexando "_v2" ao nome original) e mude o <em>status</em> de editável. Imprima a tupla.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=4aa72a46e7ea4f52e828af74395573ce">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let file_details: (String, u64, bool) = (String::from("test.txt"), 127, true);
    println!("{:#?}", file_details);

    let mut file_details_v2 = file_details;
    file_details_v2.0 = String::from("teste_v2.txt");
    file_details_v2.2 = false;

    println!("{:#?}", file_details_v2);
}</code></pre></pre>
</details>
<p>20 - Declare um array meses contendo os nomes dos três primeiros meses do ano como string <em>slices</em>. Imprima o nome do segundo mês (lembre-se da indexação baseada em zero).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=26393a352228d5e79fd2d317aa890a16">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let meses: [&amp;str; 3] = ["Janeiro", "Fevereiro", "Março"];

    println!("{:#?}\n", meses);
    println!("{:#?}", meses[1])
}</code></pre></pre>
</details>
<p>21 - Declare um array numeros de 6 elementos do tipo u32. Inicialize-o com os valores [1, 2, 4, 8, 16, 32]. Imprima o último elemento do array usando indexação.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=308cda5bbd20145c7e609b90d3be56d7">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let numeros: [u8; 6] = [1, 2, 4, 8, 16, 32];
    println!("{numeros:#?}\n");
    
    let numeros: [u8; 6] = [1, 2, 4, 8, 16, 32];
    println!("{:#?}", numeros[5]);
}</code></pre></pre>
</details>
<p>22 - Declare um array let <em>scores</em> = [100, 90, 80];. Tente modificar o segundo elemento para 95. O que acontece? Agora, declare-o como mut, faça a modificação e imprima.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=51f6763c194ff3e39be5e8a1bae04af0">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let scores = [100, 90, 80];
    println!("{:?}", scores);

    // scores[1] = 95;
    // println!("{:?}", scores);

    let mut scores = [10, 30, 60];
    println!("{:?}", scores);

    scores[1] = 0;
    println!("{:?}", scores);
}</code></pre></pre>
</details>
<p>23 - Declare um array mutável contador de 4 elementos do tipo u16, inicializado com [10, 25, 5, 30]. Modifique a contagem do primeiro item para 12 e do terceiro para 8. Imprima o array atualizado.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a535592a4b7e3a8858732b7890f5f27e">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let mut contador: [u16; 4] = [10, 25, 5, 30];

    contador[0] = 12;
    contador[3] = 8;

    println!("{:?}", contador);
}</code></pre></pre>
</details>
<p>24 - Crie um array mutável servicos_ativos: [bool; 3] inicializado como [true, false, true]. Modifique o segundo serviço para <em>true</em> e o último para <em>false</em>. Imprima o array.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=4b380922973da309b12e0085d2798fa0">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let mut servicos_ativos:[bool; 3] = [true, false, true];
    println!("{:?}", servicos_ativos);

    servicos_ativos[1] = true;
    servicos_ativos[2] = false;
    println!("{:?}", servicos_ativos);
}</code></pre></pre>
</details>
<p>25 - Crie um array mutável pixel_colors: [[u8; 3]; 2] para representar dois pixels, cada um com componentes R, G, B. Inicialize-o como [[255, 0, 0], [0, 255, 0]] (um pixel vermelho, um verde). Modifique o primeiro pixel para ser azul ([0, 0, 255]) e o segundo para ser amarelo ([255, 255, 0]). Imprima o array de pixels.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=d4c64d7affe4fe5a1f01f576394ca5dd">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    let mut pixel_colors: [[u8; 3]; 2] = [[255, 0, 0], [0, 255, 0]];
    println!("Vermelho: {:?}", pixel_colors[0]);
    println!("Verde: {:?}", pixel_colors[1]);

    // Red &gt; Blue
    pixel_colors[0][0] = 0;
    pixel_colors[0][1] = 0;
    pixel_colors[0][2] = 255;

    // Green &gt; Yellow
    pixel_colors[1][0] = 255;
    pixel_colors[1][1] = 255;
    pixel_colors[1][2] = 0;
    
    println!("Azul: {:?}", pixel_colors[0]);    
    println!("Amarelo: {:?}", pixel_colors[1]);
}</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operadores"><a class="header" href="#operadores">Operadores</a></h1>
<p>Este capítulo se aprofunda nos diversos operadores disponíveis em Rust, que são ferramentas essenciais para realizar operações em dados e controlar o fluxo do programa. Os operadores permitem manipular valores, fazer comparações e executar operações lógicas que formam o núcleo de qualquer lógica de programação.</p>
<p>Dominar esses operadores é fundamental para escrever um código Rust expressivo e eficiente. Eles servem como os blocos de construção para operações e algoritmos mais complexos que você desenvolverá à medida que avança.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operadores-aritméticos"><a class="header" href="#operadores-aritméticos">Operadores Aritméticos</a></h1>
<p>Usados para cálculos matemáticos básicos.</p>
<p><code>+</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let adi = 1 + 1;
println!("Adição = {:?}", adi);
<span class="boring">}</span></code></pre></pre>
<p><code>-</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sub = 2 - 2;
println!("Subtração = {:?}", sub);
<span class="boring">}</span></code></pre></pre>
<p><code>*</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mul = 3 * 3;
println!("Multiplicação = {:?}", mul);
<span class="boring">}</span></code></pre></pre>
<p><code>/</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let div = 4 / 4;
println!("Divisão = {:?}", div);
<span class="boring">}</span></code></pre></pre>
<p><code>%</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rest = 5 % 5;
println!("Resto Divisão = {:?}", rest);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operadores-de-atribuição"><a class="header" href="#operadores-de-atribuição">Operadores de Atribuição</a></h1>
<p>Usados para atribuir valores a variáveis.</p>
<p><code>+=</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num: u8 = 10;

// adição e atribuição: +=
num += 1;
println!("10 += 1 = {}", num);
<span class="boring">}</span></code></pre></pre>
<p><code>-=</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num: u8 = 10;

// subtração e atribuição: -=
num -= 1;
println!("10 -= 1 = {}", num);
<span class="boring">}</span></code></pre></pre>
<p><code>*=</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num: u8 = 10;

// multiplicação e atribuição: *=
num *= 2;
println!("10 *= 2 = {}", num);
<span class="boring">}</span></code></pre></pre>
<p><code>/=</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num: u8 = 20;

// divisão e atribuição: /=
num /= 3;
println!("20 /= 3 = {}", num);
<span class="boring">}</span></code></pre></pre>
<p><code>%=</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num: u8 = 6;

// resto e atribuição: %=
num %= 4;
println!("6 %= 4 = {}", num);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="precedência"><a class="header" href="#precedência">Precedência</a></h1>
<p>A ordem na qual as operações são realizadas em uma expressão, sendo a ordem de prioridade: (), *, /, %, + e -</p>
<p><code>()</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let preced: [i8; 2] = [5, 3];
println!("{:?}", preced[0] + preced[1] * preced[1]);

// ()
println!("{:?}", (preced[0] + preced[1]) * preced[1]);
<span class="boring">}</span></code></pre></pre>
<p><code>*, / e %</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let preced: [i8; 2] = [5, 3];
println!("{:?}", preced[0] * preced[1] / preced[1] % preced[1]);
<span class="boring">}</span></code></pre></pre>
<p><code>+ e -</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let preced: [i8; 2] = [5, 3];
println!("{:?}", preced[0] + preced[1] - preced[0] + preced[0] * preced[0]);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparação"><a class="header" href="#comparação">Comparação</a></h1>
<p>O ato de verificar se dois ou mais itens são iguais, diferentes ou ordenados em relação um ao outro.</p>
<p><code>== (igual a)</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 1;
println!("{}", a == b);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 2;
let b = 3;
println!("{}", a == b);
<span class="boring">}</span></code></pre></pre>
<p><code>!= (diferente de)</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 1;
println!("{}", a != b);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 2;
let b = 3;
println!("{}", a != b);
<span class="boring">}</span></code></pre></pre>
<p><code>&gt; (maior que)</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 1;
println!("{}", a &gt; b);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 2;
let b = 3;
println!("{}", a &gt; b);
<span class="boring">}</span></code></pre></pre>
<p><code>&lt; (menor que)</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 1;
println!("{}", a &lt; b);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 2;
let b = 3;
println!("{}", a &lt; b);
<span class="boring">}</span></code></pre></pre>
<p><code>&gt;= (maior ou igual)</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 1;
println!("{}", a &gt;= b);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 2;
let b = 3;
println!("{}", a &gt;= b);
<span class="boring">}</span></code></pre></pre>
<p><code>&lt;= (menor ou igual)</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 1;
println!("{}", a &lt;= b);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 2;
let b = 3;
println!("{}", a &lt;= b);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lógicos"><a class="header" href="#lógicos">Lógicos</a></h1>
<p>Relacionados a operações que combinam ou modificam valores booleanos (verdadeiro/falso) para produzir um único resultado booleano.</p>
<p><code>AND (E) - Somente verdadeiro quando ambos são verdadeiros</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AND = &amp;&amp;
println!("Verdadeiro &amp;&amp; Verdadeiro = {}", true &amp;&amp; true);
println!("Verdadeiro &amp;&amp; Falso = {}", true &amp;&amp; false);
println!("Falso &amp;&amp; Verdadeiro = {}", false &amp;&amp; true);
println!("Falso &amp;&amp; Falso = {}", false &amp;&amp; false);
<span class="boring">}</span></code></pre></pre>
<p><code>OR (OU) - Verdadeiro quando pelo menos um é verdadeiro</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// OR = ||
println!("Verdadeiro || Verdadeiro = {}", true || true);
println!("Verdadeiro || Falso = {}", true || false);
println!("Falso || Verdadeiro = {}", false || true);
println!("Falso || Falso = {}", false || false);
<span class="boring">}</span></code></pre></pre>
<p><code>NOT (NÃO) - Sempre inverte o valor</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOT = !
println!("!Verdadeiro = {}", !true);
println!("!Falso = {}", !false);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Você entenderá melhor seu uso quando estiver estudando estruturas de controle.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-e-str-1"><a class="header" href="#string-e-str-1">String e &amp;str</a></h1>
<p>A concatenação de String e &amp;str é o processo de unir sequências de caracteres. Em Rust, você pode usar o operador + ou a macro format!() para concatenar strings.</p>
<p><code>string</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let conc_texto_a: String = String::from("Sense");
let conc_texto_b: String = String::from(" Life");
println!("{}", conc_texto_a + &amp;conc_texto_b);
<span class="boring">}</span></code></pre></pre>
<p><code>&amp;str</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let conc_texto_a: &amp;str = "Calvin";
let conc_texto_b: &amp;str = " e Haroldo";
println!("{}", conc_texto_a.to_owned() + conc_texto_b);
<span class="boring">}</span></code></pre></pre>
<p><code>string + &amp;str</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parte_a: &amp;str = "ão";
let parte_b: String = String::from("Lampi");
println!("{}", parte_b + parte_a);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parte_a: &amp;str = "O Menino";
let parte_b: String = String::from("Maluquinho");
println!("{}", parte_a.to_owned() + " " + &amp;parte_b);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parte_a: String = String::from("Rei de");
let parte_b: &amp;str = "Lata";

let resultado: String =  parte_a + " " +parte_b;
println!("{}", resultado);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuplas-1"><a class="header" href="#tuplas-1">Tuplas</a></h1>
<p>Armazenam múltiplos itens de dados de tipos diferentes em uma estrutura de tamanho fixo.</p>
<p><code>tupla</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (u8, u8) = (1, 4);
println!("{:?}", tup.0 + tup.1);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (u8, u8);
tup = (3, 8);
println!("{:?}", tup.0 + tup.1);
<span class="boring">}</span></code></pre></pre>
<p><code>tupla + tupla</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: ((u8, u8),(u8, u8)) = ((2, 4),(6, 16));

println!("{:?}", tup.0.0 + tup.0.1);
println!("{:?}", tup.1.0 + tup.1.1);
println!("{:?}", tup.0.0 + tup.1.0);
println!("{:?}", tup.0.1 + tup.1.1);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup_01: (u8, u8) = (1, 4);
let tup_02: (u8, u8) = (14, 9);

let result = tup_01.0 + tup_01.1 + tup_02.0 + tup_02.1;
println!("{:?}", result);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-1"><a class="header" href="#array-1">Array</a></h1>
<p>Uma lista de itens de dados que são todos do mesmo tipo e têm um tamanho fixo.</p>
<p><code>array</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr: [u8; 2] = [1, 4];
println!("{:?}", arr[0] + arr[1]);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr: [u8; 2];
arr = [3, 8];
println!("{:?}", arr[0] + arr[1]);
<span class="boring">}</span></code></pre></pre>
<p><code>array + array</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr: [[u8; 2]; 2] = [[2, 4], [6, 16]];

println!("{:?}", arr[0][0] + arr[0][1]);
println!("{:?}", arr[1][0] + arr[1][1]);
println!("{:?}", arr[0][0] + arr[1][0]);
println!("{:?}", arr[0][1] + arr[1][1]);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr_01: [u8; 2] = [1, 4];
let arr_02: [u8; 2] = [14, 9];

let result = arr_01[0] + arr_01[1] + arr_02[0] + arr_02[1];
println!("{:?}", result);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questões---operadores"><a class="header" href="#questões---operadores">Questões - Operadores</a></h1>
<hr />
<p>01 - Escreva um programa que declare duas variáveis inteiras, a com o valor 15 e b com o valor 7, e imprima a soma delas.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=7feb7d291368ebf581aaab5742f75e27">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: u8 = 15;
    let b: u8 = 7;

    println!("{:?}", a + b);
}</code></pre></pre>
</details>
<p>02 - Crie um código que subtraia o valor 3 de uma variável chamada total que é inicialmente igual a 10, e exiba o resultado.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a1e9b22a5c5153747a95ebb4fe8bf72c">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let total = 10;
    let sub = total - 3;
    println!("{:?}", sub);

    //
    let mut total = 10;
    total -= 3;
    println!("{:?}", total);
}</code></pre></pre>
</details>
<p>03 - Desenvolva um programa que multiplique duas variáveis, x igual a 6 e y igual a 8, e mostre o produto.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=c8dee74c5746893c8162b93bbf9a2155">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: u8 = 6;
    let y: u8 = 8;

    let result: u8 = x * y;
    println!("{:?}", result);
}</code></pre></pre>
</details>
<p>04 - Implemente um código que divida o número 20 por 5 e imprima o quociente.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=c9c0957a0ce8bf388f3afcad0a5403f7">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let result = 20 / 5;
    println!("{}", result);
}</code></pre></pre>
</details>
<p>05 - Escreva um programa que calcule o resto da divisão de 23 por 4 e imprima o resultado.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=2e11eab852acf6f01dced1298323bfdc">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut resto: u8 = 23;
    resto %= 4;

    println!("{:?}", resto);
}</code></pre></pre>
</details>
<p>06 - Declare duas variáveis num1 = 12 e num2 = 5 e imprima o resultado da soma delas diretamente dentro da macro println!.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=2f8d469756ef776809c7842fef0dd459">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num1: u8 = 12;
    let num2: u8 = 5;

    println!("{:?}", num1 + num2);
}</code></pre></pre>
</details>
<p>07 - Crie uma variável imutável chamada valor que seja a soma de 9 e 2, e imprima seu valor.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=fc55a0910d4683d00f7128fb8354d510">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let valor: u8 = 9 + 2;
    println!("{:?}", valor);
}</code></pre></pre>
</details>
<p>08 - Declare uma variável mutável chamada contador com um valor inicial de 5. Incremente-a em 3 usando o operador de atribuição de adição (+=) e imprima o novo valor.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=22abc589c2df05f0d1755534aeb39673">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut contador: u8 = 5;
    contador += 3;

    println!("{:?}", contador);
}</code></pre></pre>
</details>
<p>09 - Crie uma variável mutável <em>score</em> inicializada com 20. Decremente-a em 5 usando o operador de atribuição de subtração (-=) e exiba o valor final.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=455fe1de3efee00f559f1cd93f31b0d0">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut score: u8 = 20;
    score -= 5;

    println!("{:?}", score);
}</code></pre></pre>
</details>
<p>10 - Declare uma variável mutável numero com o valor 2. Multiplique-a por 4 usando o operador de atribuição de multiplicação (*=) e imprima o resultado.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=3381e440513bc705a5f40461a9349b7b">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero: u8 = 2;
    numero *= 4;

    println!("{:?}", numero);
}</code></pre></pre>
</details>
<p>11 - Inicialize uma variável mutável <em>size</em> com 30. Divida-a por 6 usando o operador de atribuição de divisão (/=) e mostre o valor resultante.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=b29566fd9d99312fb3dc1ff57e5951b3">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut size: u8 = 30;
    size /= 6;

    println!("{:?}", size);
}</code></pre></pre>
</details>
<p>12 - Declare uma variável mutável numero com o valor 17. Calcule o resto da divisão por 5 usando o operador de atribuição de resto (%=) e imprima o valor.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=2bd65bcb34bbb6cac33b9565c66eae3f">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero: u8 = 17;
    numero %= 5;

    println!("{:?}", numero);
}</code></pre></pre>
</details>
<p>13 - Declare duas variáveis do tipo &amp;str, part1 com <em>Hello,</em> e part2 com Rust!. Concatene-as e imprima o resultado.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=097242c5284c799aff632b1b49f5a212">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let part1: &amp;str = "Hello, ";
    let part2: &amp;str = "Rust!";

    println!("{}{}", part1, part2);
}</code></pre></pre>
</details>
<p>14 - Crie duas variáveis do tipo string, s1 = "Linguagem " e s2 = "Rust.". Concatene-as e imprima a string resultante.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=4f17b4ebd7cda1a51d4211862f23d149">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1: String = String::from("Linguagem ");
    let s2: String = String::from("Rust.");

    println!("{:?}", s1 + &amp;s2);
}</code></pre></pre>
</details>
<p>15 - Declare uma variável do tipo &amp;str chamada numero com o valor "Numero: ". Crie uma variável do tipo string chamada numero_str com o valor "42". Concatene-as e imprima o resultado.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8476876fd7949b8ff7dc33dd2e87a9f8">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero: &amp;str = "Numero: ";
    let numero_str: String = String::from("42");

    println!("{:?}", numero.to_owned() + &amp;numero_str);
}</code></pre></pre>
</details>
<p>16 - Declare uma tupla com dois i32. Inicialize-a com os valores (5, -2). Imprima a multiplicação desses dois valores.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=d4ebdf281170d5443a1208f542aa80c3">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, i32) = (5, -2);
    println!("{:?}", tup.0 * tup.1);
}</code></pre></pre>
</details>
<p>17 - Crie uma tupla aninhada: ((1, 2), (3, 4)). Some o primeiro elemento da primeira tupla ao segundo elemento da segunda tupla e imprima o resultado.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=bb8d475522354cddf835ceb615a68bc6">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: ((u8, u8), (u8, u8)) = ((1, 2), (3, 4));
    println!("{:?}", tup.0 .0 + tup.1 .1);
}</code></pre></pre>
</details>
<p>18 - Declare duas tuplas, t1 com (2, 5) e t2 com (8, 1). Some todos os elementos das duas tuplas e imprima o total.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=370072efba7ba108d32eccb9ce76e99f">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t1: (u8, u8) = (2, 5);
    let t2: (u8, u8) = (8, 1);

    println!("{:?}", t1.0 + t1.1 + t2.0 + t2.1);
}</code></pre></pre>
</details>
<p>19 - Declare um array = [i32; 5] com os valores [1, 3, 5, 7, 9]. Imprima a soma do primeiro e último elementos.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=4bebed46cce9e86e39415d2bd1e13cad">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arr: [i32; 5] = [1, 3, 5, 7, 9];
    println!("{:?} + {:?} = {:?}", arr[0], arr[4], arr[0] + arr[4]);
}</code></pre></pre>
</details>
<p>20 - Crie um array de [u16; 3]. Inicialize-o com os valores [10, 20, 30]. Imprima o produto de todos os elementos.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=7ef61f36ac502409b15823a54d524973">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arr: [i32; 3];
    arr = [10, 20, 30];

    println!("{:?}", arr[0] * arr[1] * arr[2]);
}</code></pre></pre>
</details>
<p>21 - Declare um array multidimensional 2x2 com inteiros. Multiplique todos os elementos e imprima o resultado.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=96232ed146b87c4ad010e1bb7f41b2af">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let arr: [[i8; 2]; 2];
    arr = [[2, 2], [4, 4]];

    println!("{:?}", arr[0][0] * arr[0][1] * arr[1][0] * arr[1][1]);
}</code></pre></pre>
</details>
<p>22 - Declare uma variável x com valor 1. Crie um bloco interno onde você declare uma variável y com valor 2. Dentro do bloco, imprima a soma de x e y. Fora do bloco, tente imprimir y (o que acontecerá?).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8519e0370fd1db58ed0819cd1809ce93">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: u8 = 1;
    {
        let y: u8 = 2;
        println!("{:?}", x + y);
    }
    
    println!("{:?}", x);
    // println!("{:?}", y); // Erro: `y` fora escopo
}</code></pre></pre>
</details>
<p>23 - Declare uma variável level1 com valor 10. Abra um novo bloco e declare uma variável level2 com valor 20. Dentro deste bloco, crie outro bloco e declare level3 com valor 30. Imprima a soma de level1, level2 e level3 dentro do bloco mais interno.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8021fc32068bfeb8124dddb8ad279a25">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let level1: u8 = 10;
    {
        let level2: u8 = 20;
        {
            let level3: u8 = 30;
            println!("{:?}", level1 + level2 + level3);
        }
        println!("{:?}", level2);
    }
    println!("{:?}", level1);
}</code></pre></pre>
</details>
<p>24 - Declare uma variável principal com valor 100. Crie um bloco onde você declare uma variável com o mesmo nome e atribua o valor 50.0. Imprima o valor da variável dentro do bloco e fora do bloco.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=978acb2a3ccd4fd2267198df38e2d6dc">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num: u8 = 100;
    println!("{:?}", num);
    {
      let num: f32 = 50.;
      println!("{:?}", num);
    }
    println!("{:?}", num);
}</code></pre></pre>
</details>
<p>25 - Usando os valores de um array var = [2, 3], escreva um código que calcule e imprima o resultado de (var[0] + var[1]) * var[1].</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=f908146c0b9078f7b0333bf76268a411">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let var: [u8; 2] = [2, 3];
    println!("{:?}", (var[0] + var[1]) * var[1]);
}</code></pre></pre>
</details>
<p>26 - Ainda com a variável var = [2, 3], calcule e imprima var[0] * var[1] / var[1] % var[1].</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=44430c88d99c08cdf35532a6ce96f627">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let var: [u8; 2] = [2, 3];
    println!("{:?}", var[0] * var[1] / var[1] % var[1]);
}</code></pre></pre>
</details>
<p>27 - Calcule e imprima var[0] + var[1] − var[0] + var[0] * var[0]. (Usando var com [2, 3]).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=211402c21730bdf5f283c65022dde779">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let var: [u8; 2] = [2, 3];
    println!("{:?}", var[0] + var[1] - var[0] + var[0] * var[0]);
}</code></pre></pre>
</details>
<p>28 - Calcule e imprima ((var[0] + var[1]) − (var[0] + var[0]) * var[0]). (Usando var com [2, 3]).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=6b9bffb51d0539d84c56744e40df9d30">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let var: [i8; 2] = [2, 3];
    println!("{:?}", (var[0] + var[1]) - (var[0] + var[0]) * var[0]);
}</code></pre></pre>
</details>
<p>29 - Declare duas variáveis inteiras, num1 com valor 10 e num2 com valor 10. Escreva um código que imprima se num1 é igual a num2 (==).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=394d1d21d32acaf849af1a5eae0669e1">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num1: i8 = 10;
    let num2: i8 = 10;

    println!("Num1 = Num2? {:?} ", num1 == num2);
}</code></pre></pre>
</details>
<p>30 - Declare duas variáveis de ponto flutuante, f1 com 3.14 e f2 com 2.71. Escreva um código que imprima se f1 é diferente de f2 (!=).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=f3656ae43e2ab188cae10600f2096ac8">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let f1: f32 = 3.14;
    let f2: f32 = 2.71;

    println!("f1 != f2? {}", f1 != f2);
}</code></pre></pre>
</details>
<p>31 - Declare duas variáveis inteiras, idade_a com 25 e idade_b com 30. Escreva um código que imprima se idade_a é maior que idade_b (&gt;).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=02f5e82bcd5f3b0d2d04bad07c30b75c">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let idade_a: u8 = 25;
    let idade_b: u8 = 30;

    println!("Idade A &gt; Idade B? {}", idade_a &gt; idade_b);
}</code></pre></pre>
</details>
<p>32 - Declare duas variáveis inteiras, point1 com 5 e point2 com 8. Escreva um código que imprima se point1 é menor que point2 (&lt;).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=37dcf64ec5f78e638d924d4b5a438bb6">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let point_1: u8 = 5;
    let point_2: u8 = 8;

    println!("Point-1 &lt; Point-2? {}", point_1 &lt; point_2);
}</code></pre></pre>
</details>
<p>33 - Declare duas variáveis inteiras, nota_a com 7 e nota_b com 7. Escreva um código que imprima se nota_a é maior ou igual a nota_b (&gt;=).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=1a792ff0ba3888a97b14a359971bf9b5">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let nota_a: u8 = 7;
    let nota_b: u8 = 7;

    println!("Nota A &gt;= Nota B? {}", nota_a &gt;= nota_b);
}</code></pre></pre>
</details>
<p>34 - Declare duas variáveis float, altura_a com 1.70 e altura_b com 1.65. Escreva um código que imprima se altura_a é menor ou igual a altura_b (&lt;=).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=454112211f392feba14f52b52d241064">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let altura_a: f32 = 1.70;
    let altura_b: f32 = 1.65;

    println!("Altura A &lt;= Altura B? {}", altura_a &lt;= altura_b);
}</code></pre></pre>
</details>
<p>35 - Declare uma variável temp_a com 22.5 e temp_b com 20.0. Verifique se temp_a é maior que temp_b (&gt;) e imprima.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=623d5d1e75e8863b1752f3ce644e3a01">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let temp_a: f32 = 22.5;
    let temp_b: f32 = 20.;

    println!("Temperatura A &gt; Temperatura B? {}", temp_a &gt; temp_b);
}</code></pre></pre>
</details>
<p>36 - Declare uma variável count_a com 100 e count_b com 99. Verifique se count_a é menor que count_b (&lt;) e imprima.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=2a8a501e2f6ff7c937b09863c4dd5dd4">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let count_a: u8 = 100;
    let count_b: u8 = 99;

    println!("Count A &lt; Count B? {}", count_a &lt; count_b);
}</code></pre></pre>
</details>
<p>37 - Declare duas variáveis u8, val_a com 8 e val_b com 3. Calcule a soma, subtraia 1 do resultado, e imprima.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=74c122d32f2e76180ae11a648ce8e34a">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let val_a: u8 = 8;
    let val_b: u8 = 3;

    println!("{:?}", (val_a + val_b) - 1);
}</code></pre></pre>
</details>
<p>38 - Declare um array [i32; 3] = [2, 4, 6]. Divida cada elemento por 2 (usando atribuição de divisão se aplicável) e imprima o array resultante.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=e2eca68c484165860a912159e51ce310">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut arr: [i32; 3] = [2, 4, 6];

    arr[0] /= 2;
    arr[1] /= 2;
    arr[2] /= 2;

    println!("{:#?}", arr);
}</code></pre></pre>
</details>
<p>39 - Declare uma tupla (f64, f64) = (2.5, 3.5). Some os elementos e imprima o resultado formatado com duas casas decimais.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=f9838f28b2592946eb30eebbf3c64831">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (f64, f64) = (2.5, 3.5);
    let result: f64 = tup.0 + tup.1;

    println!("{:.2}", result);
}</code></pre></pre>
</details>
<p>40 - Declare uma variável mensagem do tipo &amp;str com "<em>Start</em>". Anexe a ela a String " -&gt; End". Imprima o valor final de mensagem.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=315cf9e1bc21c3392111d5398889d6f1">Playground!</a></p>
<details>
<summary>Resposta</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //&amp;str
    let mensagem: &amp;str = "Start";
    println!("{}", mensagem.to_owned() + " -&gt; End");
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // String
    let mut mensagem: String = String::from("Start");
    mensagem += " -&gt; End";
    println!("{}", mensagem);
}</code></pre></pre>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
